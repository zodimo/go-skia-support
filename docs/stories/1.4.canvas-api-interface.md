<!-- Powered by BMAD™ Core -->

# Story 1.4: Canvas API Interface

## Status
Ready for Review

---

## Story

**As a** developer using the go-skia-support library,  
**I want** a Canvas API interface that I can implement to provide my own graphics backend,  
**so that** I can use the library's helper functions and drawing primitives with any rendering backend (OpenGL, Vulkan, Metal, CPU, etc.) while maintaining backend-agnostic design.

---

## Acceptance Criteria

1. Canvas interface defined in `skia/interfaces/canvas.go` matching Skia C++ `SkCanvas` virtual method signatures
2. All core drawing primitives supported:
   - `DrawPaint()` - Fill entire canvas with paint
   - `DrawRect()` - Draw rectangle
   - `DrawRRect()` - Draw rounded rectangle
   - `DrawDRRect()` - Draw double rounded rectangle (donut shape)
   - `DrawOval()` - Draw oval/ellipse
   - `DrawArc()` - Draw arc segment
   - `DrawPath()` - Draw path geometry
   - `DrawPoints()` - Draw point array
3. Clipping operations supported:
   - `ClipRect(rect Rect, op ClipOp, doAntiAlias bool)` - Clip to rectangle
   - `ClipRRect(rrect RRect, op ClipOp, doAntiAlias bool)` - Clip to rounded rectangle
   - `ClipPath(path SkPath, op ClipOp, doAntiAlias bool)` - Clip to path
4. Transformation state management:
   - `Save() int` - Save current state, returns save count
   - `Restore()` - Restore to previous save
   - `RestoreToCount(saveCount int)` - Restore to specific save count
   - `GetSaveCount() int` - Get current save stack depth
   - `Concat(matrix SkMatrix)` - Concatenate transformation matrix
   - `Translate(dx Scalar, dy Scalar)` - Translate by offset
   - `Scale(sx Scalar, sy Scalar)` - Scale by factors
   - `Rotate(degrees Scalar)` - Rotate by angle (degrees)
   - `Skew(sx Scalar, sy Scalar)` - Skew by factors
5. Interface methods match C++ `SkCanvas` public API method signatures from `include/core/SkCanvas.h`:
   - Reference: `skia-source/include/core/SkCanvas.h` public methods (lines 1287-1584 for drawing, 876-1151 for transforms/clips)
   - Method signatures match exactly what Skia developers call (e.g., `drawRect(const SkRect&, const SkPaint&)` → `DrawRect(rect Rect, paint SkPaint)`)
   - Parameter names and order match C++ API to feel familiar to Skia developers
6. Interface uses existing Go types from the library:
   - `interfaces.SkPaint` for paint parameters
   - `interfaces.SkPath` for path geometry
   - `models.Rect` for rectangles
   - `models.RRect` for rounded rectangles
   - `models.Point` for coordinates
   - `interfaces.SkMatrix` for transformations
7. Interface documentation includes:
   - C++ source file references for each method
   - Method signatures matching C++ semantics
   - Usage examples showing backend implementation pattern
8. Interface follows Go naming conventions:
   - Exported methods use `PascalCase`
   - Method names match C++ API semantics (e.g., `DrawRect` not `DrawRectangle`)
9. Interface is minimal and focused - only methods users must implement, not helper methods
10. Interface design supports the library's "Bring Your Own Graphics Backend" (BYOG) philosophy

---

## Tasks / Subtasks

- [x] Task 1: Review C++ SkCanvas Virtual Methods (AC: 5)
  - [x] Read `skia-source/include/core/SkCanvas.h` lines 2378-2436 (virtual onDraw methods)
  - [x] Read `skia-source/include/core/SkCanvas.h` lines 2431-2436 (virtual onClip methods)
  - [x] Document all virtual methods that need to be exposed as interface methods
  - [x] Identify which methods are essential vs. optional for MVP
  - [x] Map C++ parameter types to Go types from the library

- [x] Task 2: Define Core Drawing Primitive Methods (AC: 2)
  - [x] Create `DrawPaint(paint SkPaint)` method signature (matching C++ `void drawPaint(const SkPaint&)`)
  - [x] Create `DrawRect(rect Rect, paint SkPaint)` method signature (matching C++ `void drawRect(const SkRect&, const SkPaint&)`)
  - [x] Create `DrawRRect(rrect RRect, paint SkPaint)` method signature (matching C++ `void drawRRect(const SkRRect&, const SkPaint&)`)
  - [x] Create `DrawDRRect(outer RRect, inner RRect, paint SkPaint)` method signature (matching C++ `void drawDRRect(const SkRRect&, const SkRRect&, const SkPaint&)`)
  - [x] Create `DrawOval(oval Rect, paint SkPaint)` method signature (matching C++ `void drawOval(const SkRect&, const SkPaint&)`)
  - [x] Create `DrawArc(oval Rect, startAngle Scalar, sweepAngle Scalar, useCenter bool, paint SkPaint)` method signature (matching C++ `void drawArc(const SkRect&, SkScalar, SkScalar, bool, const SkPaint&)`)
  - [x] Create `DrawPath(path SkPath, paint SkPaint)` method signature (matching C++ `void drawPath(const SkPath&, const SkPaint&)`)
  - [x] Create `DrawPoints(mode PointMode, points []Point, paint SkPaint)` method signature (matching C++ `void drawPoints(PointMode, SkSpan<const SkPoint>, const SkPaint&)`)
  - [x] Add C++ source references as comments for each method (lines 1287-1584)

- [x] Task 3: Define Clipping Methods (AC: 3)
  - [x] Create `ClipRect(rect Rect, op ClipOp, doAntiAlias bool)` method signature (matching C++ `clipRect(const SkRect&, SkClipOp, bool)`)
  - [x] Create `ClipRRect(rrect RRect, op ClipOp, doAntiAlias bool)` method signature (matching C++ `clipRRect(const SkRRect&, SkClipOp, bool)`)
  - [x] Create `ClipPath(path SkPath, op ClipOp, doAntiAlias bool)` method signature (matching C++ `clipPath(const SkPath&, SkClipOp, bool)`)
  - [x] Define `ClipOp` enum (Intersect, Difference, Union, XOR, ReverseDifference) matching C++ `SkClipOp`
  - [x] Add C++ source references as comments for each method (lines 1019-1151)

- [x] Task 4: Define Transformation State Methods (AC: 4)
  - [x] Create `Save() int` method signature (matching C++ `int save()`, returns save count)
  - [x] Create `Restore()` method signature (matching C++ `void restore()`)
  - [x] Create `RestoreToCount(saveCount int)` method signature (matching C++ `void restoreToCount(int)`)
  - [x] Create `GetSaveCount() int` method signature (matching C++ `int getSaveCount() const`)
  - [x] Create `Concat(matrix SkMatrix)` method signature (matching C++ `void concat(const SkMatrix&)`)
  - [x] Create `Translate(dx Scalar, dy Scalar)` method signature (matching C++ `void translate(SkScalar, SkScalar)`)
  - [x] Create `Scale(sx Scalar, sy Scalar)` method signature (matching C++ `void scale(SkScalar, SkScalar)`)
  - [x] Create `Rotate(degrees Scalar)` method signature (matching C++ `void rotate(SkScalar)`)
  - [x] Create `Skew(sx Scalar, sy Scalar)` method signature (matching C++ `void skew(SkScalar, SkScalar)`)
  - [x] Add C++ source references as comments for each method (lines 876-988)

- [x] Task 5: Create Canvas Interface File (AC: 1, 6, 7, 8, 9, 10)
  - [x] Create `skia/interfaces/canvas.go` file
  - [x] Define `SkCanvas` interface with all drawing methods
  - [x] Define `SkCanvas` interface with all clipping methods
  - [x] Define `SkCanvas` interface with all transformation methods
  - [x] Add package-level documentation explaining BYOG philosophy
  - [x] Add interface-level documentation with usage example
  - [x] Add method-level documentation with C++ source references
  - [x] Ensure all types reference existing library types (no new types unless necessary)
  - [x] Follow Go naming conventions and export rules

- [x] Task 6: Define Supporting Enums (AC: 3, 4)
  - [x] Add `ClipOp` enum to `skia/enums/enums.go` (if not exists) - matches C++ `SkClipOp` enum
  - [x] Add `PointMode` enum to `skia/enums/enums.go` (if not exists) - matches C++ `SkCanvas::PointMode` enum
  - [x] Reference C++ source: `include/core/SkClipOp.h` and `include/core/SkCanvas.h` (PointMode definition)
  - [x] Ensure enum values match C++ constants exactly
  - [x] Note: `doAntiAlias bool` parameter replaces C++ `ClipEdgeStyle` enum (simpler Go API)

- [x] Task 7: Add Interface Documentation (AC: 7)
  - [x] Add package doc comment explaining Canvas interface purpose
  - [x] Add example showing how to implement Canvas interface
  - [x] Add example showing how to use Canvas with helper functions
  - [x] Document C++ source file references for each method group
  - [x] Add note about backend-agnostic design philosophy

---

## Dev Notes

### Relevant Source Tree Info

**Interface Location:**
- New file: `skia/interfaces/canvas.go`
- Follows existing pattern: `skia/interfaces/paint.go`, `skia/interfaces/path.go`, `skia/interfaces/matix.go`

**C++ Source References:**
- Primary reference: `skia-source/include/core/SkCanvas.h`
  - **Public API methods** (what Skia developers call):
    - Drawing methods: lines 1287-1584 (`drawPaint`, `drawRect`, `drawPath`, `drawOval`, `drawRRect`, `drawDRRect`, `drawArc`, `drawPoints`, etc.)
    - Transformation methods: lines 876-988 (`save`, `restore`, `restoreToCount`, `translate`, `scale`, `rotate`, `skew`, `concat`)
    - Clipping methods: lines 1019-1151 (`clipRect`, `clipRRect`, `clipPath`)
  - Virtual methods (internal implementation): lines 2378-2436 (for reference only)
- Canvas class documentation: lines 92-113
- Canvas overview: `skia-source/site/docs/user/api/_index.md` lines 61-86
- Example usage: `skia-source/docs/examples/skcanvas_paint.cpp`

**Existing Library Types to Use:**
- `interfaces.SkPaint` - Paint interface (already exists)
- `interfaces.SkPath` - Path interface (already exists)
- `interfaces.SkMatrix` - Matrix interface (already exists)
- `models.Rect` - Rectangle model (already exists)
- `models.RRect` - Rounded rectangle model (already exists)
- `models.Point` - Point model (already exists)
- `base.Scalar` - Floating-point type (already exists)

**New Types Needed:**
- `ClipOp` enum - Clip operation type (Intersect, Difference, Union, XOR, ReverseDifference) - matches C++ `SkClipOp`
- `PointMode` enum - Point drawing mode (Points, Lines, Polygon) - matches C++ `SkCanvas::PointMode`

**C++ Public API to Go Interface Mapping:**

**Drawing Methods** (matching public API signatures that Skia developers call):

| C++ Public Method | Go Interface Method | Parameters |
|------------------|---------------------|------------|
| `void drawPaint(const SkPaint& paint)` | `DrawPaint(paint SkPaint)` | paint |
| `void drawRect(const SkRect& rect, const SkPaint& paint)` | `DrawRect(rect Rect, paint SkPaint)` | rect, paint |
| `void drawRRect(const SkRRect& rrect, const SkPaint& paint)` | `DrawRRect(rrect RRect, paint SkPaint)` | rrect, paint |
| `void drawDRRect(const SkRRect& outer, const SkRRect& inner, const SkPaint& paint)` | `DrawDRRect(outer RRect, inner RRect, paint SkPaint)` | outer, inner, paint |
| `void drawOval(const SkRect& oval, const SkPaint& paint)` | `DrawOval(oval Rect, paint SkPaint)` | oval, paint |
| `void drawArc(const SkRect& oval, SkScalar startAngle, SkScalar sweepAngle, bool useCenter, const SkPaint& paint)` | `DrawArc(oval Rect, startAngle Scalar, sweepAngle Scalar, useCenter bool, paint SkPaint)` | oval, startAngle, sweepAngle, useCenter, paint |
| `void drawPath(const SkPath& path, const SkPaint& paint)` | `DrawPath(path SkPath, paint SkPaint)` | path, paint |
| `void drawPoints(PointMode mode, SkSpan<const SkPoint> pts, const SkPaint& paint)` | `DrawPoints(mode PointMode, points []Point, paint SkPaint)` | mode, points, paint |

**Clipping Methods** (matching public API signatures):

| C++ Public Method | Go Interface Method | Parameters |
|------------------|---------------------|------------|
| `void clipRect(const SkRect& rect, SkClipOp op, bool doAntiAlias)` | `ClipRect(rect Rect, op ClipOp, doAntiAlias bool)` | rect, op, doAntiAlias |
| `void clipRRect(const SkRRect& rrect, SkClipOp op, bool doAntiAlias)` | `ClipRRect(rrect RRect, op ClipOp, doAntiAlias bool)` | rrect, op, doAntiAlias |
| `void clipPath(const SkPath& path, SkClipOp op, bool doAntiAlias)` | `ClipPath(path SkPath, op ClipOp, doAntiAlias bool)` | path, op, doAntiAlias |

**Transformation Methods** (matching public API signatures):

| C++ Public Method | Go Interface Method | Parameters |
|------------------|---------------------|------------|
| `int save()` | `Save() int` | Returns save count |
| `void restore()` | `Restore()` | None |
| `void restoreToCount(int saveCount)` | `RestoreToCount(saveCount int)` | saveCount |
| `int getSaveCount() const` | `GetSaveCount() int` | Returns current save count |
| `void concat(const SkMatrix& matrix)` | `Concat(matrix SkMatrix)` | matrix |
| `void translate(SkScalar dx, SkScalar dy)` | `Translate(dx Scalar, dy Scalar)` | dx, dy |
| `void scale(SkScalar sx, SkScalar sy)` | `Scale(sx Scalar, sy Scalar)` | sx, sy |
| `void rotate(SkScalar degrees)` | `Rotate(degrees Scalar)` | degrees |
| `void skew(SkScalar sx, SkScalar sy)` | `Skew(sx Scalar, sy Scalar)` | sx, sy |

**Note:** Method signatures match the public C++ API exactly (what Skia developers call), not the internal virtual methods. Parameter names match C++ conventions to feel familiar.

### Method Behavior Reference

The following sections document the expected behavior of each method, extracted from Skia C++ documentation and implementation. Implementers should follow these behaviors to ensure compatibility with Skia semantics.

**Reference:** `skia-source/include/core/SkCanvas.h` - All behavior documentation extracted from C++ header comments.

#### Drawing Methods Behavior

**`DrawPaint(paint SkPaint)`**
- **C++ Reference:** `void drawPaint(const SkPaint& paint)` - line 1287
- **Behavior:** Fills the current clip region with the specified paint. The paint's color, blend mode, shader, color filter, and image filter affect drawing.
- **Paint Components:** 
  - **Applied:** Shader, ColorFilter, ImageFilter, BlendMode affect drawing
  - **Ignored:** MaskFilter and PathEffect in paint are ignored (have no effect)
- **Transformation:** The paint is applied to the clip region, not transformed by the current matrix (fills clip directly).
- **Clip:** Fills the current clip region (not the entire canvas). If no clip is set, fills the entire canvas.
- **Use Cases:** Clearing the clip region with a color, applying a background shader, or filling with a pattern within the clip.

**`DrawRect(rect Rect, paint SkPaint)`**
- **C++ Reference:** `void drawRect(const SkRect& rect, const SkPaint& paint)` - line 1406
- **Behavior:** Draws a rectangle using the current clip, matrix transformation, and paint properties.
- **Paint Style:** `PaintStyle` determines if rectangle is stroked or filled:
  - `PaintStyleFill`: Fills the rectangle interior
  - `PaintStyleStroke`: Strokes the rectangle outline
  - `PaintStyleStrokeAndFill`: Both fills and strokes
- **Stroke Properties:** If stroked, `StrokeWidth` describes line thickness, `PaintJoin` draws corners (rounded or square).
- **Transformation:** Rectangle coordinates are transformed by the current matrix before drawing.
- **Clip:** Drawing is clipped to the current clip region.
- **Edge Cases:** Empty rectangles (width or height <= 0) may be ignored or drawn as a line depending on implementation.

**`DrawRRect(rrect RRect, paint SkPaint)`**
- **C++ Reference:** `void drawRRect(const SkRRect& rrect, const SkPaint& paint)` - line 1457
- **Behavior:** Draws a rounded rectangle with up to eight corner radii (four corners, each with x and y radii).
- **Paint Style:** Same as `DrawRect` - `PaintStyle` determines stroked or filled.
- **Corner Radii:** Each corner can have independent x and y radii. If radii are zero, draws as a regular rectangle.
- **Radii Constraints:** If radii exceed rectangle dimensions, they are scaled down to fit.
- **Transformation:** RRect is transformed by the current matrix before drawing.
- **Clip:** Drawing is clipped to the current clip region.
- **Use Cases:** Buttons, cards, rounded UI elements.

**`DrawDRRect(outer RRect, inner RRect, paint SkPaint)`**
- **C++ Reference:** `void drawDRRect(const SkRRect& outer, const SkRRect& inner, const SkPaint& paint)` - line 1478
- **Behavior:** Draws a "donut" shape - the area between outer and inner rounded rectangles.
- **Constraint:** `outer` must contain `inner` or drawing behavior is undefined.
- **Paint Style:** Same as `DrawRect` - `PaintStyle` determines stroked or filled.
- **Optimization:** GPU-backed platforms optimize when both outer and inner are concave and outer contains inner.
- **Transformation:** Both Rects are transformed by the current matrix before drawing.
- **Clip:** Drawing is clipped to the current clip region.
- **Use Cases:** Rings, borders with rounded corners, progress indicators.

**`DrawOval(oval Rect, paint SkPaint)`**
- **C++ Reference:** `void drawOval(const SkRect& oval, const SkPaint& paint)` - line 1443
- **Behavior:** Draws an oval (ellipse) bounded by the specified rectangle.
- **Paint Style:** `PaintStyle` determines if oval is stroked or filled. If stroked, `StrokeWidth` describes line thickness.
- **Transformation:** Rectangle bounds are transformed by the current matrix before drawing the oval.
- **Clip:** Drawing is clipped to the current clip region.
- **Edge Cases:** Empty rectangles (width or height <= 0) result in no drawing.
- **Use Cases:** Circles (when rect is square), ellipses, rounded shapes.

**`DrawArc(oval Rect, startAngle Scalar, sweepAngle Scalar, useCenter bool, paint SkPaint)`**
- **C++ Reference:** `void drawArc(const SkRect& oval, SkScalar startAngle, SkScalar sweepAngle, bool useCenter, const SkPaint& paint)` - line 1527
- **Behavior:** Draws an arc that is part of an oval bounded by `oval`, sweeping from `startAngle` to `startAngle + sweepAngle`.
- **Angles:** Angles are in degrees. Zero degrees places start point at the right middle edge of oval (3 o'clock position).
- **Direction:** Positive `sweepAngle` is clockwise; negative is counterclockwise. `sweepAngle` may exceed 360 degrees (full circle).
- **useCenter:** 
  - `true`: Draws a wedge including lines from oval center to arc end points
  - `false`: Draws only the arc between end points
- **Edge Cases:** If `oval` is empty or `sweepAngle` is zero, nothing is drawn.
- **Transformation:** Oval bounds are transformed by the current matrix before drawing.
- **Clip:** Drawing is clipped to the current clip region.
- **Use Cases:** Pie charts, arc segments, partial circles.

**`DrawPath(path SkPath, paint SkPaint)`**
- **C++ Reference:** `void drawPath(const SkPath& path, const SkPaint& paint)` - line 1584
- **Behavior:** Draws a path containing one or more contours, each of which may be open or closed.
- **Paint Style:** 
  - If filled: `PathFillType` determines whether path contour describes inside or outside of fill
  - If stroked: `StrokeWidth` describes line thickness, `PaintCap` describes line ends, `PaintJoin` describes corners
- **Path Structure:** Path may contain multiple contours (each starting with MoveTo). Each contour may be open or closed.
- **Transformation:** Path geometry is transformed by the current matrix before drawing.
- **Clip:** Drawing is clipped to the current clip region.
- **Use Cases:** Complex shapes, custom geometry, vector graphics.

**`DrawPoints(mode PointMode, points []Point, paint SkPaint)`**
- **C++ Reference:** `void drawPoints(PointMode mode, SkSpan<const SkPoint> pts, const SkPaint& paint)` - line 1330
- **Behavior:** Draws an array of points according to the specified mode.
- **PointMode Behavior:**
  - `PointModePoints`: Draws each point separately. Shape depends on `PaintCap`:
    - `PaintCapRound`: Circle of diameter `StrokeWidth`
    - `PaintCapSquare` or `PaintCapButt`: Square of width/height `StrokeWidth`
  - `PointModeLines`: Each pair of points draws a line segment. One line per two points. If count is odd, final point is ignored.
  - `PointModePolygon`: Each adjacent pair draws a line segment. `count-1` lines drawn, connecting all points sequentially.
- **Paint Style:** `PaintStyle` is ignored - always treated as stroke. `PaintJoin` is ignored - elements drawn one at a time.
- **Edge Cases:** If `len(points) < 1`, has no effect.
- **Transformation:** Points are transformed by the current matrix before drawing.
- **Clip:** Drawing is clipped to the current clip region.
- **Use Cases:** Point clouds, line sequences, polyline drawing.

#### Clipping Methods Behavior

**`ClipRect(rect Rect, op ClipOp, doAntiAlias bool)`**
- **C++ Reference:** `void clipRect(const SkRect& rect, SkClipOp op, bool doAntiAlias)` - line 1019
- **Behavior:** Replaces clip with the intersection or difference of current clip and `rect`.
- **ClipOp Behavior:**
  - `ClipOpIntersect`: Clip becomes intersection of current clip and rect (default, most common)
  - `ClipOpDifference`: Clip becomes current clip minus rect
  - `ClipOpUnion`: Clip becomes union of current clip and rect
  - `ClipOpXOR`: Clip becomes XOR of current clip and rect
  - `ClipOpReverseDifference`: Clip becomes rect minus current clip
- **Anti-Aliasing:** `doAntiAlias` controls edge quality:
  - `false`: Aliased clip - pixels are fully contained by the clip (faster)
  - `true`: Anti-aliased clip - smooth edges with partial pixel coverage (slower, better quality)
- **Transformation:** `rect` is transformed by the current matrix before being combined with clip.
- **Cumulative:** Each clip operation further restricts the drawing area. Clips are cumulative and cannot be expanded (except via `Save`/`Restore`).
- **Use Cases:** Restricting drawing to a region, creating masks, UI element boundaries.

**`ClipRRect(rrect RRect, op ClipOp, doAntiAlias bool)`**
- **C++ Reference:** `void clipRRect(const SkRRect& rrect, SkClipOp op, bool doAntiAlias)` - line 1073
- **Behavior:** Replaces clip with the intersection or difference of current clip and rounded rectangle.
- **ClipOp:** Same behavior as `ClipRect` - see above.
- **Anti-Aliasing:** Same behavior as `ClipRect` - see above.
- **Transformation:** `rrect` is transformed by the current matrix before being combined with clip.
- **Corner Radii:** Each corner can have independent radii. Zero radii behave like regular rectangle clipping.
- **Cumulative:** Same as `ClipRect` - clips are cumulative and restrictive.
- **Use Cases:** Rounded UI element clipping, cards with rounded corners, buttons.

**`ClipPath(path SkPath, op ClipOp, doAntiAlias bool)`**
- **C++ Reference:** `void clipPath(const SkPath& path, SkClipOp op, bool doAntiAlias)` - line 1109
- **Behavior:** Replaces clip with the intersection or difference of current clip and path.
- **Path FillType:** `PathFillType` determines if path describes area inside or outside contours, and how overlaps are handled:
  - `PathFillTypeWinding`: Non-zero winding rule
  - `PathFillTypeEvenOdd`: Even-odd rule
  - Inverse variants describe outside instead of inside
- **ClipOp:** Same behavior as `ClipRect` - see above.
- **Anti-Aliasing:** Same behavior as `ClipRect` - see above.
- **Transformation:** `path` is transformed by the current matrix before being combined with clip.
- **Complexity:** More expensive than rect/RRect clipping due to path complexity.
- **Cumulative:** Same as `ClipRect` - clips are cumulative and restrictive.
- **Use Cases:** Complex shape clipping, custom mask shapes, irregular boundaries.

#### Transformation Methods Behavior

**`Save() int`**
- **C++ Reference:** `int save()` - line ~850 (see getSaveCount for context)
- **Behavior:** Saves the current matrix and clip state to a stack. Returns the save count (depth of stack before this save).
- **Save Count:** Initial canvas has save count of 1. Each `Save()` increments the count.
- **State Saved:** Both matrix transformation and clip region are saved.
- **Return Value:** Returns the save count before this save operation (can be used with `RestoreToCount`).
- **Use Cases:** Temporary transformations, nested drawing contexts, grouping operations.

**`Restore()`**
- **C++ Reference:** `void restore()` - line 876
- **Behavior:** Removes the most recent save state from the stack, restoring matrix and clip to previous values.
- **Edge Cases:** Does nothing if the stack is empty (save count is 1).
- **State Restored:** Both matrix and clip are restored to their state at the last `Save()` call.
- **Use Cases:** Restoring state after temporary transformations, ending grouped operations.

**`RestoreToCount(saveCount int)`**
- **C++ Reference:** `void restoreToCount(int saveCount)` - line 898
- **Behavior:** Restores state to the matrix and clip values when `Save()` returned `saveCount`.
- **Edge Cases:** 
  - Does nothing if `saveCount` is greater than current state stack count
  - Restores to initial values if `saveCount` is less than or equal to 1
- **Use Cases:** Restoring to a specific save point, cleaning up multiple save levels at once.

**`GetSaveCount() int`**
- **C++ Reference:** `int getSaveCount() const` - line 886
- **Behavior:** Returns the number of saved states (depth of save stack).
- **Initial State:** New canvas has save count of 1.
- **Calculation:** Equals number of `Save()` calls less number of `Restore()` calls plus one.
- **Use Cases:** Debugging, state validation, ensuring proper save/restore pairing.

**`Concat(matrix SkMatrix)`**
- **C++ Reference:** `void concat(const SkMatrix& matrix)` - line 987
- **Behavior:** Replaces current matrix with `matrix` premultiplied with existing matrix.
- **Mathematical Effect:** `newMatrix = matrix * currentMatrix` (matrix applied first, then current transformation).
- **Order:** The `matrix` transformation is applied to geometry first, then the existing matrix transformation.
- **Use Cases:** Applying custom transformations, combining multiple transformations, complex matrix operations.

**`Translate(dx Scalar, dy Scalar)`**
- **C++ Reference:** `void translate(SkScalar dx, SkScalar dy)` - line 913
- **Behavior:** Translates the current matrix by `dx` along x-axis and `dy` along y-axis.
- **Mathematical Effect:** Premultiplies current matrix with a translation matrix.
- **Effect:** Moves drawing by `(dx, dy)` before applying existing matrix transformation.
- **Use Cases:** Positioning elements, offsetting drawing, moving coordinate origin.

**`Scale(sx Scalar, sy Scalar)`**
- **C++ Reference:** `void scale(SkScalar sx, SkScalar sy)` - line 928
- **Behavior:** Scales the current matrix by `sx` on x-axis and `sy` on y-axis.
- **Mathematical Effect:** Premultiplies current matrix with a scale matrix.
- **Effect:** Scales drawing by `(sx, sy)` before applying existing matrix transformation.
- **Edge Cases:** Negative values mirror/flip. Zero values collapse dimension.
- **Use Cases:** Zooming, scaling UI elements, aspect ratio adjustments.

**`Rotate(degrees Scalar)`**
- **C++ Reference:** `void rotate(SkScalar degrees)` - line 942
- **Behavior:** Rotates the current matrix by `degrees` around the origin (0, 0).
- **Mathematical Effect:** Premultiplies current matrix with a rotation matrix.
- **Direction:** Positive degrees rotates clockwise (mathematical convention).
- **Effect:** Rotates drawing by `degrees` around origin before applying existing matrix transformation.
- **Use Cases:** Rotating elements, angled text, orientation changes.

**`Skew(sx Scalar, sy Scalar)`**
- **C++ Reference:** `void skew(SkScalar sx, SkScalar sy)` - line 976
- **Behavior:** Skews the current matrix by `sx` on x-axis and `sy` on y-axis.
- **Mathematical Effect:** Premultiplies current matrix with a skew matrix.
- **Direction:** 
  - Positive `sx`: Skews right as y-axis values increase
  - Positive `sy`: Skews down as x-axis values increase
- **Effect:** Skews drawing by `(sx, sy)` before applying existing matrix transformation.
- **Use Cases:** Perspective effects, italic text simulation, distortion effects.

### Implementation Notes

**Matrix Transformation Order:**
- All drawing operations apply transformations in this order: `Geometry → Current Matrix → Clip → Render`
- Transformation methods (`Translate`, `Scale`, `Rotate`, `Skew`, `Concat`) modify the current matrix
- The current matrix is applied to all geometry before clipping and rendering

**Clip Behavior:**
- Clips are cumulative and restrictive - each clip operation further limits the drawing area
- Clips cannot be expanded except by restoring to a previous save state
- Clips are applied after matrix transformation
- Anti-aliased clips provide smoother edges but are more expensive

**Save/Restore Stack:**
- The save stack maintains both matrix and clip state
- Initial state (save count = 1) cannot be restored past
- Proper pairing of `Save()` and `Restore()` is essential for correct behavior
- `RestoreToCount` provides a way to restore to any previous save point

**Paint Properties:**
- All drawing methods respect paint properties (color, style, stroke width, blend mode, filters)
- Paint properties are applied after geometry transformation and clipping
- Blend modes determine how drawn pixels combine with existing pixels

**Performance Considerations:**
- Clipping operations are cumulative and can become expensive with complex paths
- Anti-aliased clipping is more expensive than aliased clipping
- Path clipping is more expensive than rect/RRect clipping
- Matrix transformations are relatively cheap (just matrix math)

**Design Principles:**
1. **Familiar to Skia Developers:** Method signatures match C++ public API exactly (what developers call), not internal virtual methods
2. **Parameter Naming:** Parameter names match C++ conventions (e.g., `rect`, `paint`, `oval`, `rrect`, `path`, `dx`, `dy`, `sx`, `sy`)
3. **Minimal Interface:** Only include methods users must implement, not helper methods
4. **Backend Agnostic:** Interface doesn't assume any specific rendering backend
5. **Type Reuse:** Use existing library types (Paint, Path, Matrix, Rect, etc.)
6. **C++ Parity:** Method signatures match C++ API semantics and calling conventions
7. **Go Conventions:** Follow Go naming and export conventions while maintaining Skia familiarity

**Integration with Existing Code:**
- Canvas interface will be used by helper functions (future work)
- Canvas interface enables users to implement their own backends
- Existing Paint, Path, Matrix implementations work with Canvas interface
- No changes needed to existing implementations

**Notes from Previous Stories:**
- Story 1.1-1.3 established Paint, Path, and Matrix implementations
- These implementations are ready to be used with Canvas interface
- Canvas interface provides the bridge between library primitives and user backends

### Testing

**Test File Location:**
- Interface tests: `skia/interfaces/canvas_test.go` (to be created in future story)
- Mock implementations for testing helper functions

**Testing Standards:**
- Interface definition doesn't require tests (it's a contract)
- Future stories will test Canvas implementations
- Mock Canvas implementations will be used to test helper functions

**Testing Frameworks:**
- Standard Go testing (`testing` package)
- No external testing frameworks required for interface definition

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-27 | 1.0 | Initial story creation | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used
Composer (BMAD Developer Agent)

### Debug Log References
None

### Completion Notes List
- All tasks completed successfully
- Created `skia/interfaces/canvas.go` with complete SkCanvas interface
- Added ClipOp and PointMode enums to `skia/enums/enums.go`
- All method signatures match C++ public API from `include/core/SkCanvas.h`
- Interface uses existing library types (SkPaint, SkPath, SkMatrix, Rect, RRect, Point, Scalar)
- Comprehensive documentation added with C++ source references
- Code compiles successfully with no linting errors
- Note: ClipOp enum includes Union, XOR, and ReverseDifference operations as specified in story, even though current C++ SkClipOp.h only defines kDifference and kIntersect

### File List
- Created: `skia/interfaces/canvas.go`
- Modified: `skia/enums/enums.go` (added ClipOp and PointMode enums)

---

## QA Results
_To be populated by QA agent_

